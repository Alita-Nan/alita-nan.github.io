# 有关操作系统的第一个程序


# 

## Before

​	这两天回到家之后便因为一些琐事中断了学习。果然还是和我预料的一样，得呆在学校那种环境下才能静得下来。虽然如此，但是在前几天的学习中我的收获还是颇为丰富。这本书在不断细化和深入的过程也会用程序来直观的让读者感受操作系统。这次的笔记也是源自于书中第四章——抽象：进程。

# 一、书的大致逻辑

> 虚拟化技术 -> 如何模拟出尽可能多的CPU从而同时执行尽可能多的任务（进程）？ -> 抽象需要执行的**任务** 	-> 引出了进程的概念

​	这本书是围绕三个部分讲的，其中第一部分就是**虚拟化**技术。我们知道我们现在的机器都能同时进行不同的任务。但是我们的cpu数量是有限的，也就是说执行任务的逻辑不可能是线性的，类似队列模式的。有过高级编程语言学习经验的你肯定知道，在**并发**编程中，cpu是在不同的线程中来回切换从而达到“**并发**”。

* 那么为什么要产生进程这一概念呢？

​	先让我们来回顾一下小学接触过的数学题：假设洗漱要10分钟，榨汁机榨果汁要5分钟，煮开水要7分钟。请问完成这三件事最短的时间是多少（榨汁和煮水的前置工作的时间不计）？显然的，答案是10分钟。因为你可以在启动榨汁机和煮水壶之后再去洗漱。我们换个角度，把你看成一块CPU，这三件事情都是用户需要执行的不同**任务**。CPU也和你一样不会线性的、耐心的依次等待三个任务的完成。而是会选择最佳的策略在尽可能短的时间内去同时完成这三件任务。所以这要求你必须能在任何时刻都能清点”进程“在执行过程中访问或影响系统的不同部分（就像你能知道水是否烧开了，热水壶放置在哪个地方等等……）

​	关于书上对进程API的介绍（如进程的创建、销毁、暂停等），在此处就不过多赘述了。

# 二、 书中给出的程序

​	书中给出的习题是运行给定的程序并根据所学知识和提示回答。下面是本章给出的习题：

![Test_Four_1](/Test_Four_1.jpg)



![Test_Four_2](/Test_Four_2.jpg)



* **如果你对给出的程序感兴趣的话可以到下面的连接拉取（本次的程序在*cpu-intro***文件夹下）

* **如果你没梯子的话那么可以将连接中的github.com替换成：*****github.com.cnpmjs.org***

* **本程序的运行需要你有python的编译环境。**

  > https://github.com/remzi-arpacidusseau/ostep-homework/

# 三、运行结果与结论

> 这里先明确运行的指令和参数：5:100表示的是一个需要5个单位时间且运行时要占用cpu 100%的资源的程序。相反的，3:0表示的是需要花费1个单位时间且这个时间通常花费在发起请求上，但在处理过程中不耗费cpu资源的程序（例如IO的处理，且io的处理默认花费5个单位时长）

###### 首先我们来看一下2、3题。

> 题目的要求翻译一下就是要执行一个占用cpu百分之一百的资源且需要4个单位时间才能完成的程序和一个io程序。区别只是执行的顺序不同。

* 运行结果分别如图所示：

{{< figure src="/run-4-2.JPG" title="第二题运行结果" >}}



{{< figure src="/run-4-3.JPG" title="第三题运行结果" >}}

* 可以看到虽然要执行的都是相同的任务，但是花费的时间却有所不同。原因在于处理IO程序时cpu并不需要参与其中。就像我们在前面提到的数学题中的烧水一样。你只需要按下开关，水壶便会自动加水和加热。这个过程你可以去处理其他的事情。**所以cpu的一个执行策略便是在等待io时切换到另一个进程继续处理。**

###### 接下来我们来看一下6、7题。

> 为了便于展示这里我们只运行两个 5:100的程序。指令中的参数在题目中均有介绍，此处便不过多赘述。

* 运行结果如图：

{{< figure src="/run-4-6.JPG" title="第六题运行结果" >}}



{{< figure src="/run-4-7.JPG" title="第七题运行结果" >}}

* 这里的思路是和上面的2、3题的思路相似。区别就是指令中的两个参数能够让cpu的处理时先发出等待中的io程序，然后切换到其他进程运行，借此缩短运行时间。

# 四、总结

通过上述的题目，我们可以看到操作系统在处理进程时必须给出一套执行策略供cpu运行以在有限的范围内缩短运行时间，为此我们抽象出了进程这一概念。让cpu在”烧水“的同时洗漱。


